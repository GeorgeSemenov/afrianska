'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
	if (e && e.__esModule) { return e; } else {
		var n = {};
		if (e) {
			Object.keys(e).forEach(function (k) {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () {
						return e[k];
					}
				});
			});
		}
		n['default'] = e;
		return n;
	}
}

var stylelint = _interopDefault(require('stylelint'));
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var postcss = _interopDefault(require('postcss'));

function parse(string, splitByAnd) {
  const array = [];
  let buffer = '';
  let split = false;
  let func = 0;
  let i = -1;

  while (++i < string.length) {
    const char = string[i];

    if (char === '(') {
      func += 1;
    } else if (char === ')') {
      if (func > 0) {
        func -= 1;
      }
    } else if (func === 0) {
      if (splitByAnd && andRegExp.test(buffer + char)) {
        split = true;
      } else if (!splitByAnd && char === ',') {
        split = true;
      }
    }

    if (split) {
      array.push(splitByAnd ? new MediaExpression(buffer + char) : new MediaQuery(buffer));
      buffer = '';
      split = false;
    } else {
      buffer += char;
    }
  }

  if (buffer !== '') {
    array.push(splitByAnd ? new MediaExpression(buffer) : new MediaQuery(buffer));
  }

  return array;
}

class MediaQueryList {
  constructor(string) {
    this.nodes = parse(string);
    this.nodeType = 'list';
  }

  invert() {
    this.nodes.forEach(node => {
      node.invert();
    });
    return this;
  }

  clone() {
    return new MediaQueryList(String(this));
  }

  toString() {
    return this.nodes.join(',');
  }

}

class MediaQuery {
  constructor(string) {
    const [, before, media, after] = string.match(spaceWrapRegExp);
    const [, modifier = '', afterModifier = ' ', type = '', beforeAnd = '', and = '', beforeExpression = '', expression1 = '', expression2 = ''] = media.match(mediaRegExp) || [];
    const raws = {
      before,
      after,
      afterModifier,
      originalModifier: modifier || '',
      beforeAnd,
      and,
      beforeExpression
    };
    const nodes = parse(expression1 || expression2, true);
    Object.assign(this, {
      modifier,
      type,
      raws,
      nodes,
      nodeType: 'query'
    });
  }

  clone(overrides) {
    const instance = new MediaQuery(String(this));
    Object.assign(instance, overrides);
    return instance;
  }

  invert() {
    this.modifier = this.modifier ? '' : this.raws.originalModifier;
    return this;
  }

  toString() {
    const {
      raws
    } = this;
    return `${raws.before}${this.modifier}${this.modifier ? `${raws.afterModifier}` : ''}${this.type}${raws.beforeAnd}${raws.and}${raws.beforeExpression}${this.nodes.join('')}${this.raws.after}`;
  }

}

class MediaExpression {
  constructor(string) {
    const [, value, after = '', and = '', afterAnd = ''] = string.match(andRegExp) || [null, string];
    const raws = {
      after,
      and,
      afterAnd
    };
    Object.assign(this, {
      value,
      raws,
      nodeType: 'expression'
    });
  }

  clone(overrides) {
    const instance = new MediaExpression(String(this));
    Object.assign(instance, overrides);
    return instance;
  }

  toString() {
    const {
      raws
    } = this;
    return `${this.value}${raws.after}${raws.and}${raws.afterAnd}`;
  }

}

const modifierRE = '(not|only)';
const typeRE = '(all|print|screen|speech)';
const noExpressionRE = '([\\W\\w]*)';
const expressionRE = '([\\W\\w]+)';
const noSpaceRE = '(\\s*)';
const spaceRE = '(\\s+)';
const andRE = '(?:(\\s+)(and))';
const andRegExp = new RegExp(`^${expressionRE}(?:${andRE}${spaceRE})$`, 'i');
const spaceWrapRegExp = new RegExp(`^${noSpaceRE}${noExpressionRE}${noSpaceRE}$`);
const mediaRegExp = new RegExp(`^(?:${modifierRE}${spaceRE})?(?:${typeRE}(?:${andRE}${spaceRE}${expressionRE})?|${expressionRE})$`, 'i');
var parseMedia = (string => new MediaQueryList(string));

// return custom selectors from the css root
var getCustomMediaFromRoot = (root => {
  // initialize custom selectors
  const customMedias = {}; // for each @custom-media at-rule

  root.nodes.forEach(node => {
    if (isCustomMedia(node)) {
      // extract the name and selectors from the params of the custom selector
      const [, name, selectors] = node.params.match(customMediaParamsRegExp); // write the parsed selectors to the custom selector

      customMedias[name] = selectors;
    }
  }); // return all custom medias

  return customMedias;
}); // match the custom selector name

const customMediaNameRegExp = /^custom-media$/i; // match the custom selector params

const customMediaParamsRegExp = /^(--[A-z][\w-]*)\s+([\W\w]+)\s*$/; // whether the atrule is a custom selector

const isCustomMedia = node => node.type === 'atrule' && customMediaNameRegExp.test(node.name) && customMediaParamsRegExp.test(node.params);

/* Get Custom Media from CSS File
/* ========================================================================== */

async function getCustomMediaFromCSSFile(from) {
  const css = await readFile(from);
  const root = postcss.parse(css, {
    from
  });
  return getCustomMediaFromRoot(root);
}
/* Get Custom Media from Object
/* ========================================================================== */


function getCustomMediaFromObject(object) {
  const customMedia = Object.assign({}, Object(object).customMedia, Object(object)['custom-media']);
  return customMedia;
}
/* Get Custom Media from JSON file
/* ========================================================================== */


async function getCustomMediaFromJSONFile(from) {
  const object = await readJSON(from);
  return getCustomMediaFromObject(object);
}
/* Get Custom Media from JS file
/* ========================================================================== */


async function getCustomMediaFromJSFile(from) {
  const object = await Promise.resolve().then(function () { return _interopNamespace(require(from)); });
  return getCustomMediaFromObject(object);
}
/* Get Custom Media from Imports
/* ========================================================================== */


function getCustomMediaFromImports(sources) {
  return sources.map(source => {
    if (source instanceof Promise) {
      return source;
    } else if (source instanceof Function) {
      return source();
    } // read the source as an object


    const opts = source === Object(source) ? source : {
      from: String(source)
    }; // skip objects with Custom Media

    if (opts.customMedia || opts['custom-media']) {
      return opts;
    } // source pathname


    const from = path.resolve(String(opts.from || '')); // type of file being read from

    const type = (opts.type || path.extname(from).slice(1)).toLowerCase();
    return {
      type,
      from
    };
  }).reduce(async (customMedia, source) => {
    const {
      type,
      from
    } = await source;

    if (type === 'css') {
      return Object.assign(await customMedia, await getCustomMediaFromCSSFile(from));
    }

    if (type === 'js') {
      return Object.assign(await customMedia, await getCustomMediaFromJSFile(from));
    }

    if (type === 'json') {
      return Object.assign(await customMedia, await getCustomMediaFromJSONFile(from));
    }

    return Object.assign(await customMedia, await getCustomMediaFromObject(await source));
  }, {});
}
/* Promise-ified utilities
/* ========================================================================== */

const readFile = from => new Promise((resolve, reject) => {
  fs.readFile(from, 'utf8', (error, result) => {
    if (error) {
      reject(error);
    } else {
      resolve(result);
    }
  });
});

const readJSON = async from => JSON.parse(await readFile(from));

const ruleName = 'csstools/media-use-custom-media';
var index = stylelint.createPlugin(ruleName, (method, opts) => {
  // sources to import custom selectors from
  const importFrom = [].concat(Object(opts).importFrom || []); // conditionally promise any custom selectors are imported

  const customMediaPromise = isMethodAlwaysKnown(method) || isMethodKnown(method) ? getCustomMediaFromImports(importFrom) : {};
  return async (root, result) => {
    // valid methods are: "always" || "always-known" || "never" || "known" || true || false || null
    const validOptions = stylelint.utils.validateOptions(result, ruleName, {
      actual: method,

      possible() {
        return isMethodAlways(method) || isMethodAlwaysKnown(method) || isMethodIndifferent(method) || isMethodKnown(method) || isMethodNever(method);
      }

    }); // conditionally enforce the use of custom media

    if (validOptions && !isMethodIndifferent(method)) {
      // all custom properties from the file and imports
      const customMedia = isMethodAlwaysKnown(method) || isMethodKnown(method) ? Object.assign(await customMediaPromise, getCustomMediaFromRoot(root)) : {}; // check every @media at-rule

      root.walkAtRules(mediaAtRuleNameRegExp, atrule => {
        const mediaAST = parseMedia(atrule.params);
        let word = `@${atrule.name}`; // check whether media queries are using custom media references

        const isCorrectlyUsingMedia = mediaAST.nodes.every(node => node.nodes.every(child => {
          // whether the expression is like @media (--foo)
          const isCustomExpression = checkCustomExpression(child);
          const returnValue = isCustomExpression ? isMethodKnown(method) || isMethodAlwaysKnown(method) // @media (--foo) && ("always-known" || "known") && @custom-media --foo bar;
          ? child.value.slice(1, -1) in customMedia // @media (--foo) && "always"
          : isMethodAlways(method) // !@media (--foo) && ("known" || "never")
          : isMethodKnown(method) || isMethodNever(method);

          if (!returnValue) {
            word = String(child);
          }

          return returnValue;
        })); // conditionally report media queries not using custom media references

        if (!isCorrectlyUsingMedia) {
          stylelint.utils.report({
            message: isMethodNever(method) ? messages.unexpected(atrule.params) : messages.expected(atrule.params),
            node: atrule,
            result,
            ruleName,
            word
          });
        }
      });
    }
  };
});
const messages = stylelint.utils.ruleMessages(ruleName, {
  expected(expression) {
    return `Expected a custom media query instead of "${expression}".`;
  },

  unexpected(expression) {
    return `Expected no custom media query instead of "${expression}".`;
  }

});
const mediaAtRuleNameRegExp = /^media$/i;
const customMediaExpressionRegExp = /\(--[\w-]+\)/i;

const checkCustomExpression = node => node.nodeType === 'expression' && customMediaExpressionRegExp.test(node.value);

const isMethodIndifferent = method => method === 'ignore' || method === null;

const isMethodAlways = method => method === 'always' || method === true;

const isMethodAlwaysKnown = method => method === 'always-known';

const isMethodKnown = method => method === 'known';

const isMethodNever = method => method === 'never' || method === false;

exports.default = index;
exports.messages = messages;
exports.ruleName = ruleName;
//# sourceMappingURL=index.js.map
